# 支持商城自定义开发使用说明


## 说明

> 此方案采用嵌入iframe的方式。已在本地和测试线上做了验证，该方案可以达到支持商城自定义开发。原理是在流桌面端嵌入商城开发的页面，在首次进入流桌面端时也会请求自定义开发页面，之后缓存下来，然后采用事件机制,html5的postMessage告诉双方要你去做什么。

<br />

### 官方键盘数据定义示例

``` javascript
  // 封装的iframe组件
  <iframeView
    ref="iframeView"
    :showIframe="isSidwbar"
    :src="viewUrl"
    :fullScreenStatus="fullScreenStatus"
    @openTxtKeyboard="showKey"
    @createKeyboard="createClick"
    @leaveTemporarily="away"
    @changeFullScreenStatus="showFullScreen"
    @changeMouseMode="isChoose"
    @useOfficialKeyboard="useOfficialKeyboard"
    @hiddenCustomSlidebar="showSidebar"
    :showFullScreenSwitch="showFullScreenSwitch"
    @useMyCustomKeyboard="useMyCustomKeyboard"
    @editMyCustomKeyboard="editMyCustomKeyboard"
    @deleteMyCustomKeyboard="deleteMyCustomKeyboard"
    @changeMouseSpeed="changeMouseSpeed"
  >
  </iframeView>

  // iframeView组件内，监听子页面发来的消息并作处理，通过postMessage去给子页面发送命令
  handleMessage (event) {
    let data = event.data
    console.log(data.cmd)
    if (['changeFullScreenStatus', 'changeMouseMode', 'useOfficialKeyboard', 'useMyCustomKeyboard', 'editMyCustomKeyboard', 'deleteMyCustomKeyboard', 'changeMouseSpeed'].includes(data.cmd)) {
      this.$emit(data.cmd, data.params.data)
    } else {
      this.$emit(data.cmd)
    }
  }

  window.addEventListener('message', this.handleMessage)

  this.$refs.customSlideBarIframe.contentWindow.postMessage({
    cmd: 'openSlidebar',
    params: {
      data: ''
    }
  }, '*')

  // 子页面
  // mounted生命周期内
  window.addEventListener('message', this.handleMessageFromParent)

  // 处理父页面发来的消息
  handleMessageFromParent (event) {
      var data = event.data;
      switch (data.cmd) {
          case 'getInitialFullScreenStatus':
              const { fullScrrenStatus, showFullScreenSwitch } = data.params.data
              if (showFullScreenSwitch) {
                  Vue.set(this, 'checked', fullScrrenStatus)
              } else {
                  let newArr = this.bars.filter(item => item.name !== '全屏显示')
                  Vue.set(this, 'bars', newArr)
              }
              break
          case 'openSlidebar':
              Vue.set(this, 'i', -1)
              this.goBack()
              break
          case 'getVideoStatus':
            //接受网络延迟及丢包等数据
              break
      }
  }

  // 给父页面发送命令
  window.parent.postMessage({
      cmd: 'hiddenCustomSlidebar',
      params: {
          data: ''
      }
  }, '*')
```

<br >

### 实现方式
> 根据目前的自定义商城的代码，我所实现的通信方式是，点击子页面某个命令，然后子页面告诉父页面要做什么，再调父页面的方法。再比如自定义商城调用官方键盘接口或我的键盘接口，成功拿到数据后，在点击使用、编辑、删除的时候，将接口返回的数据发送给父页面，父页面再对这个数据进行处理展示实现按下操作。如果后续想要将所有的页面交由商城处理，那么则可以总结为关于键盘的接口调用，展示，移动这些交互都由他们去做，最终在他们按下键盘的时候发送按下的命令给我们流桌面端，再处理这个按下的键。轮询

<br />

### 测试案例
1. 嵌入流桌面端的样式不会发生改变。实现基础：自定义商城编写适配移动端的样式，并排查移动端的一些样式问题。
2. 调用文字键盘响应成功，并成功按下。
3. 官方键盘自适应显示，能够成功按下。
4. 我的键盘的使用、编辑、删除功能正常。
5. 暂时离开功能使用正常。
6. 鼠标速度调节功能使用正常。
7. 鼠标模式功能使用正常。

